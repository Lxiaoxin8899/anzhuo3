# SmartDosing 后端开发与 SQLite 集成计划 v2.0

## 1. 背景与目标

### 1.1 现状分析
- **数据存储现状**：
  - 业务数据（配方、材料、模板）全部保存在内存仓库（`RecipeRepository`、`TemplateRepository`）
  - 应用重启后数据丢失，无法持久化保存
  - Web 端导入功能已支持 CSV/Excel，但数据仍写入内存集合
  - 缺乏统一的持久化层，无法进行复杂查询、筛选、统计

- **技术架构现状**：
  - ✅ 完善的数据模型（Recipe、Material、Template等）
  - ✅ 完整的REST API（Ktor Web服务器，8080端口）
  - ✅ Repository模式架构设计良好
  - ✅ CSV/Excel导入功能完整
  - ❌ 缺乏数据持久化层
  - ❌ 无数据备份和恢复机制

### 1.2 集成目标
- **核心目标**：
  - 引入本地 SQLite 数据库，使用 androidx.room 库实现可持久化的 CRUD
  - 将 Ktor Web 服务、导入模块、App 侧 UI 全量切换到数据库驱动
  - 保持现有API接口不变，降低Web端集成成本

- **扩展目标**：
  - 为后续多端同步、备份还原、权限控制等功能打下基础
  - 支持大数据量场景下的高性能查询和批量操作
  - 建立完善的错误处理和数据恢复机制

## 2. 架构梳理

### 2.1 现有模块分析
| 模块 | 现有职责 | 集成影响 | 优先级 |
| --- | --- | --- | --- |
| `RecipeRepository` | 管理配方数据，内存 `MutableStateFlow` | **重点改造**：切换到Room DAO，保持Flow接口 | P0 |
| `TemplateRepository` | 提供默认模板、导出功能 | 模板自定义部分需保存到DB，默认模板可内存维护 | P1 |
| `RecipeImportManager` | 解析 CSV/Excel，调用 `RecipeRepository.addRecipe` | 解析逻辑保留，改为批量事务写入 | P0 |
| `WebServerManager` | Ktor 路由、API 响应 | API接口保持不变，内部调用改为DAO | P1 |
| App UI（Compose） | 通过仓库获取列表/详情 | 仓库接口保持不变，需验证响应性能 | P2 |

### 2.2 新增模块
| 模块 | 职责 | 实现方式 |
| --- | --- | --- |
| `SmartDosingDatabase` | Room数据库主类 | 定义数据库版本、实体、DAO |
| `RecipeDao`/`MaterialDao` | 数据访问对象 | 提供CRUD、复杂查询、批量操作 |
| `DatabaseModule` | 依赖注入模块 | 提供数据库单例、DAO实例 |
| `DataMapper` | 数据转换器 | Entity ↔ 业务模型转换 |
| `DatabaseErrorHandler` | 错误处理器 | 处理数据库异常、备份恢复 |

## 3. 数据库设计

### 3.1 核心表结构

#### 3.1.1 配方主表 (recipes)
```sql
CREATE TABLE recipes (
    id TEXT PRIMARY KEY,                    -- 配方唯一标识
    code TEXT UNIQUE NOT NULL,              -- 配方编码（业务唯一标识）
    name TEXT NOT NULL,                     -- 配方名称
    category TEXT NOT NULL,                 -- 一级分类（香精、酸类等）
    sub_category TEXT DEFAULT '',           -- 二级分类
    customer TEXT DEFAULT '',               -- 客户名称
    batch_no TEXT DEFAULT '',               -- 批次号
    version TEXT DEFAULT '1.0',             -- 版本号
    description TEXT DEFAULT '',            -- 配方描述
    total_weight REAL NOT NULL,             -- 总重量
    create_time TEXT NOT NULL,              -- 创建时间 (ISO 8601格式)
    update_time TEXT NOT NULL,              -- 更新时间
    last_used TEXT,                         -- 最后使用时间
    usage_count INTEGER DEFAULT 0,         -- 使用次数
    status TEXT DEFAULT 'ACTIVE',          -- 状态：ACTIVE/INACTIVE/DRAFT/ARCHIVED
    priority TEXT DEFAULT 'NORMAL',        -- 优先级：LOW/NORMAL/HIGH/URGENT
    creator TEXT DEFAULT '',                -- 创建者
    reviewer TEXT DEFAULT ''                -- 审核者
);
```

#### 3.1.2 材料表 (materials)
```sql
CREATE TABLE materials (
    id TEXT PRIMARY KEY,                    -- 材料唯一标识
    recipe_id TEXT NOT NULL,                -- 关联配方ID
    name TEXT NOT NULL,                     -- 材料名称
    weight REAL NOT NULL,                   -- 重量
    unit TEXT DEFAULT 'g',                  -- 单位
    sequence INTEGER DEFAULT 1,            -- 投料顺序
    notes TEXT DEFAULT '',                  -- 备注
    FOREIGN KEY (recipe_id) REFERENCES recipes(id) ON DELETE CASCADE
);
```

#### 3.1.3 配方标签关系表 (recipe_tags)
```sql
CREATE TABLE recipe_tags (
    recipe_id TEXT NOT NULL,                -- 配方ID
    tag TEXT NOT NULL,                      -- 标签名称
    PRIMARY KEY (recipe_id, tag),
    FOREIGN KEY (recipe_id) REFERENCES recipes(id) ON DELETE CASCADE
);
```

#### 3.1.4 模板表 (templates)
```sql
CREATE TABLE templates (
    id TEXT PRIMARY KEY,                    -- 模板唯一标识
    name TEXT NOT NULL,                     -- 模板名称
    description TEXT DEFAULT '',            -- 模板描述
    version INTEGER DEFAULT 1,             -- 版本号
    updated_at TEXT NOT NULL,               -- 更新时间
    is_default BOOLEAN DEFAULT FALSE,      -- 是否为默认模板
    created_by TEXT DEFAULT 'SYSTEM'       -- 创建者（SYSTEM/USER）
);
```

#### 3.1.5 模板字段表 (template_fields)
```sql
CREATE TABLE template_fields (
    id TEXT PRIMARY KEY,                    -- 字段唯一标识
    template_id TEXT NOT NULL,              -- 关联模板ID
    field_key TEXT NOT NULL,                -- 字段键名
    label TEXT NOT NULL,                    -- 显示标签
    description TEXT DEFAULT '',            -- 字段描述
    required BOOLEAN DEFAULT TRUE,         -- 是否必填
    example TEXT DEFAULT '',                -- 示例值
    field_order INTEGER DEFAULT 0,         -- 字段顺序
    FOREIGN KEY (template_id) REFERENCES templates(id) ON DELETE CASCADE
);
```

#### 3.1.6 导入日志表 (import_logs)
```sql
CREATE TABLE import_logs (
    id TEXT PRIMARY KEY,                    -- 日志唯一标识
    file_name TEXT NOT NULL,                -- 原始文件名
    file_size INTEGER NOT NULL,             -- 文件大小(字节)
    file_type TEXT NOT NULL,                -- 文件类型(CSV/EXCEL)
    success_count INTEGER DEFAULT 0,       -- 成功导入数量
    failed_count INTEGER DEFAULT 0,        -- 失败数量
    error_details TEXT,                     -- 错误详情(JSON格式)
    import_time TEXT NOT NULL,              -- 导入时间
    import_duration INTEGER DEFAULT 0,     -- 导入耗时(毫秒)
    imported_by TEXT DEFAULT 'WEB'         -- 导入来源(WEB/APP)
);
```

### 3.2 索引设计
```sql
-- 配方表索引
CREATE UNIQUE INDEX idx_recipes_code ON recipes(code);
CREATE INDEX idx_recipes_category ON recipes(category);
CREATE INDEX idx_recipes_customer ON recipes(customer);
CREATE INDEX idx_recipes_status ON recipes(status);
CREATE INDEX idx_recipes_last_used ON recipes(last_used);
CREATE INDEX idx_recipes_create_time ON recipes(create_time);

-- 材料表索引
CREATE INDEX idx_materials_recipe_id ON materials(recipe_id);
CREATE INDEX idx_materials_sequence ON materials(recipe_id, sequence);

-- 模板字段表索引
CREATE INDEX idx_template_fields_template_id ON template_fields(template_id);
CREATE INDEX idx_template_fields_order ON template_fields(template_id, field_order);

-- 导入日志索引
CREATE INDEX idx_import_logs_time ON import_logs(import_time);
CREATE INDEX idx_import_logs_type ON import_logs(file_type);
```

### 3.3 数据约束
- **referential_integrity**: 启用外键约束
- **unique_constraints**: 配方编码全局唯一
- **check_constraints**: 重量必须大于0，状态和优先级枚举值检查
- **cascade_deletes**: 删除配方时级联删除材料和标签

## 4. Room实体设计

### 4.1 核心实体类

#### 4.1.1 配方实体 (RecipeEntity)
```kotlin
@Entity(
    tableName = "recipes",
    indices = [
        Index(value = ["code"], unique = true),
        Index(value = ["category"]),
        Index(value = ["customer"]),
        Index(value = ["status"]),
        Index(value = ["last_used"]),
        Index(value = ["create_time"])
    ]
)
data class RecipeEntity(
    @PrimaryKey val id: String,
    val code: String,
    val name: String,
    val category: String,
    @ColumnInfo(name = "sub_category") val subCategory: String = "",
    val customer: String = "",
    @ColumnInfo(name = "batch_no") val batchNo: String = "",
    val version: String = "1.0",
    val description: String = "",
    @ColumnInfo(name = "total_weight") val totalWeight: Double,
    @ColumnInfo(name = "create_time") val createTime: String,
    @ColumnInfo(name = "update_time") val updateTime: String,
    @ColumnInfo(name = "last_used") val lastUsed: String? = null,
    @ColumnInfo(name = "usage_count") val usageCount: Int = 0,
    val status: String = "ACTIVE",
    val priority: String = "NORMAL",
    val creator: String = "",
    val reviewer: String = ""
)
```

#### 4.1.2 材料实体 (MaterialEntity)
```kotlin
@Entity(
    tableName = "materials",
    indices = [
        Index(value = ["recipe_id"]),
        Index(value = ["recipe_id", "sequence"])
    ],
    foreignKeys = [
        ForeignKey(
            entity = RecipeEntity::class,
            parentColumns = ["id"],
            childColumns = ["recipe_id"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class MaterialEntity(
    @PrimaryKey val id: String,
    @ColumnInfo(name = "recipe_id") val recipeId: String,
    val name: String,
    val weight: Double,
    val unit: String = "g",
    val sequence: Int = 1,
    val notes: String = ""
)
```

#### 4.1.3 关系映射类
```kotlin
data class RecipeWithMaterials(
    @Embedded val recipe: RecipeEntity,
    @Relation(
        parentColumn = "id",
        entityColumn = "recipe_id"
    )
    val materials: List<MaterialEntity>,
    @Relation(
        parentColumn = "id",
        entityColumn = "recipe_id",
        entity = RecipeTagEntity::class,
        projection = ["tag"]
    )
    val tags: List<String>
)
```

### 4.2 DAO 接口设计

#### 4.2.1 配方DAO (RecipeDao)
```kotlin
@Dao
interface RecipeDao {

    // 基础查询
    @Query("SELECT * FROM recipes ORDER BY create_time DESC")
    fun getAllRecipesFlow(): Flow<List<RecipeEntity>>

    @Query("SELECT * FROM recipes WHERE id = :id")
    suspend fun getRecipeById(id: String): RecipeEntity?

    @Query("SELECT * FROM recipes WHERE code = :code")
    suspend fun getRecipeByCode(code: String): RecipeEntity?

    // 分页查询
    @Query("""
        SELECT * FROM recipes
        WHERE (:category IS NULL OR category = :category)
        AND (:customer IS NULL OR customer = :customer)
        AND (:status IS NULL OR status = :status)
        AND (:searchText IS NULL OR
             name LIKE '%' || :searchText || '%' OR
             code LIKE '%' || :searchText || '%' OR
             description LIKE '%' || :searchText || '%')
        ORDER BY
        CASE WHEN :sortBy = 'CREATE_TIME' AND :sortOrder = 'DESC' THEN create_time END DESC,
        CASE WHEN :sortBy = 'CREATE_TIME' AND :sortOrder = 'ASC' THEN create_time END ASC,
        CASE WHEN :sortBy = 'NAME' AND :sortOrder = 'ASC' THEN name END ASC,
        CASE WHEN :sortBy = 'NAME' AND :sortOrder = 'DESC' THEN name END DESC,
        CASE WHEN :sortBy = 'USAGE_COUNT' AND :sortOrder = 'DESC' THEN usage_count END DESC
        LIMIT :limit OFFSET :offset
    """)
    suspend fun getRecipesPaged(
        category: String?,
        customer: String?,
        status: String?,
        searchText: String?,
        sortBy: String,
        sortOrder: String,
        limit: Int,
        offset: Int
    ): List<RecipeEntity>

    // 统计查询
    @Query("SELECT COUNT(*) FROM recipes")
    suspend fun getRecipeCount(): Int

    @Query("SELECT COUNT(*) FROM recipes WHERE category = :category")
    suspend fun getRecipeCountByCategory(category: String): Int

    @Query("SELECT DISTINCT category FROM recipes ORDER BY category")
    suspend fun getAllCategories(): List<String>

    @Query("SELECT DISTINCT customer FROM recipes WHERE customer != '' ORDER BY customer")
    suspend fun getAllCustomers(): List<String>

    // 增删改
    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insertRecipe(recipe: RecipeEntity): Long

    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insertRecipes(recipes: List<RecipeEntity>)

    @Update
    suspend fun updateRecipe(recipe: RecipeEntity)

    @Delete
    suspend fun deleteRecipe(recipe: RecipeEntity)

    @Query("DELETE FROM recipes WHERE id = :id")
    suspend fun deleteRecipeById(id: String)

    // 批量操作
    @Transaction
    suspend fun insertRecipeWithMaterials(
        recipe: RecipeEntity,
        materials: List<MaterialEntity>,
        tags: List<String>
    ) {
        insertRecipe(recipe)
        insertMaterials(materials)
        insertRecipeTags(tags.map { RecipeTagEntity(recipe.id, it) })
    }

    @Insert
    suspend fun insertMaterials(materials: List<MaterialEntity>)

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertRecipeTags(tags: List<RecipeTagEntity>)

    // 关系查询
    @Transaction
    @Query("SELECT * FROM recipes WHERE id = :recipeId")
    suspend fun getRecipeWithMaterials(recipeId: String): RecipeWithMaterials?

    @Transaction
    @Query("SELECT * FROM recipes ORDER BY create_time DESC")
    fun getAllRecipesWithMaterialsFlow(): Flow<List<RecipeWithMaterials>>
}
```

### 4.3 数据库主类
```kotlin
@Database(
    entities = [
        RecipeEntity::class,
        MaterialEntity::class,
        RecipeTagEntity::class,
        TemplateEntity::class,
        TemplateFieldEntity::class,
        ImportLogEntity::class
    ],
    version = 1,
    exportSchema = true
)
@TypeConverters(DatabaseConverters::class)
abstract class SmartDosingDatabase : RoomDatabase() {

    abstract fun recipeDao(): RecipeDao
    abstract fun materialDao(): MaterialDao
    abstract fun templateDao(): TemplateDao
    abstract fun importLogDao(): ImportLogDao

    companion object {
        const val DATABASE_NAME = "smartdosing.db"

        @Volatile
        private var INSTANCE: SmartDosingDatabase? = null

        fun getDatabase(context: Context): SmartDosingDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    SmartDosingDatabase::class.java,
                    DATABASE_NAME
                )
                .addCallback(DatabaseCallback())
                .fallbackToDestructiveMigration()
                .build()
                INSTANCE = instance
                instance
            }
        }
    }

    private class DatabaseCallback : Callback() {
        override fun onCreate(db: SupportSQLiteDatabase) {
            super.onCreate(db)
            // 首次创建时在后台线程初始化数据
            CoroutineScope(Dispatchers.IO).launch {
                populateInitialData()
            }
        }

        private suspend fun populateInitialData() {
            INSTANCE?.let { database ->
                // 插入默认模板
                // 插入示例配方（可选）
            }
        }
    }
}
```

## 5. 数据映射器设计

### 5.1 Entity ↔ 业务模型转换
```kotlin
object DataMapper {

    // Recipe转换
    fun RecipeEntity.toDomainModel(materials: List<MaterialEntity>, tags: List<String>): Recipe {
        return Recipe(
            id = id,
            code = code,
            name = name,
            category = category,
            subCategory = subCategory,
            customer = customer,
            batchNo = batchNo,
            version = version,
            description = description,
            materials = materials.map { it.toDomainModel() },
            totalWeight = totalWeight,
            createTime = createTime,
            updateTime = updateTime,
            lastUsed = lastUsed,
            usageCount = usageCount,
            status = RecipeStatus.valueOf(status),
            priority = RecipePriority.valueOf(priority),
            tags = tags,
            creator = creator,
            reviewer = reviewer
        )
    }

    fun Recipe.toEntity(): RecipeEntity {
        return RecipeEntity(
            id = id,
            code = code,
            name = name,
            category = category,
            subCategory = subCategory,
            customer = customer,
            batchNo = batchNo,
            version = version,
            description = description,
            totalWeight = totalWeight,
            createTime = createTime,
            updateTime = updateTime,
            lastUsed = lastUsed,
            usageCount = usageCount,
            status = status.name,
            priority = priority.name,
            creator = creator,
            reviewer = reviewer
        )
    }

    // Material转换
    fun MaterialEntity.toDomainModel(): Material {
        return Material(
            id = id,
            name = name,
            weight = weight,
            unit = unit,
            sequence = sequence,
            notes = notes
        )
    }

    fun Material.toEntity(recipeId: String): MaterialEntity {
        return MaterialEntity(
            id = id,
            recipeId = recipeId,
            name = name,
            weight = weight,
            unit = unit,
            sequence = sequence,
            notes = notes
        )
    }
}
```

## 6. 集成实施方案

### 6.1 阶段规划

#### **阶段 0：基础准备 (1天)**
- ✅ **技术选型确认**：使用 `androidx.room` 作为数据库框架
- 📦 **依赖添加**：在 `app/build.gradle.kts` 中添加Room相关依赖
- 📋 **数据库设计确认**：完善表结构、索引、约束设计
- 🏗️ **项目结构调整**：创建 `database/` 包结构

#### **阶段 1：数据访问层实现 (2-3天)**
- 🗃️ **实体类开发**：
  - 实现 `RecipeEntity`, `MaterialEntity`, `RecipeTagEntity` 等Room实体
  - 定义关系映射类 `RecipeWithMaterials`
  - 添加类型转换器 `DatabaseConverters`
- 🔍 **DAO接口实现**：
  - `RecipeDao`：包含CRUD、分页查询、统计查询
  - `MaterialDao`：材料的增删改查和批量操作
  - `TemplateDao`：模板管理相关操作
  - `ImportLogDao`：导入日志记录
- 🗄️ **数据库主类**：
  - `SmartDosingDatabase` 配置
  - 数据库回调和初始化逻辑
  - 数据迁移策略
- 🔄 **数据映射器**：
  - Entity ↔ 业务模型双向转换
  - 扩展函数式API设计

#### **阶段 2：Repository层改造 (2天)**
- 🏪 **RecipeRepository重构**：
  - 从内存存储切换到Room DAO
  - 保持原有公开接口，内部实现改为数据库操作
  - 添加 Flow/StateFlow 响应式数据流
  - 实现复杂查询和筛选功能
- 📝 **TemplateRepository改造**：
  - 模板的持久化存储和自定义功能
  - 保留默认模板的初始化逻辑
- 🔄 **数据迁移逻辑**：
  - 首次启动时的示例数据插入
  - 从内存数据到数据库的迁移工具

#### **阶段 3：导入模块改造 (1天)**
- 📥 **RecipeImportManager重构**：
  - 解析逻辑保持不变
  - 改为使用Room事务进行批量插入
  - 优化大文件导入性能
  - 完善导入日志记录
- 📊 **导入统计优化**：
  - 更详细的 `ImportSummary` 信息
  - 失败记录的详细错误信息

#### **阶段 4：Web服务层集成 (1天)**
- 🌐 **API接口保持**：
  - Ktor路由和响应格式不变
  - 内部调用改为Repository新接口
- ⚡ **性能优化**：
  - 添加分页支持
  - 优化复杂查询性能
- 📋 **新增功能**：
  - 数据备份API
  - 导入日志查询API

#### **阶段 5：测试与验证 (2天)**
- ✅ **单元测试**：
  - DAO层测试（使用in-memory数据库）
  - Repository层测试
  - 数据映射器测试
- 🔗 **集成测试**：
  - Web API端到端测试
  - 数据导入流程测试
  - 数据一致性验证
- 📱 **UI集成测试**：
  - Android应用界面功能验证
  - 响应式数据流测试
- ⚡ **性能测试**：
  - 大数据量场景测试
  - 查询性能基准测试

### 6.2 详细任务清单

#### **6.2.1 基础设施任务**
- [ ] **build.gradle.kts 依赖配置**
  ```kotlin
  implementation "androidx.room:room-runtime:2.6.1"
  implementation "androidx.room:room-ktx:2.6.1"
  kapt "androidx.room:room-compiler:2.6.1"
  ```
- [ ] **创建数据库包结构**
  ```
  app/src/main/java/com/example/smartdosing/
  ├── database/
  │   ├── entities/
  │   ├── dao/
  │   ├── converters/
  │   └── SmartDosingDatabase.kt
  ```

#### **6.2.2 数据访问层任务**
- [ ] **实体类开发**
  - [ ] RecipeEntity（配方实体）
  - [ ] MaterialEntity（材料实体）
  - [ ] RecipeTagEntity（标签关系实体）
  - [ ] TemplateEntity/TemplateFieldEntity（模板实体）
  - [ ] ImportLogEntity（导入日志实体）
  - [ ] RecipeWithMaterials（关系映射类）
- [ ] **DAO接口实现**
  - [ ] RecipeDao（增删改查、分页、统计、搜索）
  - [ ] MaterialDao（材料管理）
  - [ ] TemplateDao（模板管理）
  - [ ] ImportLogDao（日志记录）
- [ ] **数据库配置**
  - [ ] SmartDosingDatabase主类
  - [ ] DatabaseCallback初始化逻辑
  - [ ] DatabaseConverters类型转换器

#### **6.2.3 业务层改造任务**
- [ ] **Repository改造**
  - [ ] RecipeRepository完整重构
  - [ ] TemplateRepository数据库集成
  - [ ] 数据映射器DataMapper实现
- [ ] **导入模块改造**
  - [ ] RecipeImportManager事务处理
  - [ ] 批量导入性能优化
  - [ ] 导入日志完善

#### **6.2.4 服务层集成任务**
- [ ] **Web API适配**
  - [ ] WebServerManager路由保持
  - [ ] 分页查询API优化
  - [ ] 新增备份恢复API

#### **6.2.5 测试验证任务**
- [ ] **单元测试编写**
  - [ ] RecipeDaoTest
  - [ ] RecipeRepositoryTest
  - [ ] DataMapperTest
- [ ] **集成测试编写**
  - [ ] WebAPI端到端测试
  - [ ] 数据导入集成测试
- [ ] **性能测试**
  - [ ] 大数据量查询测试
  - [ ] 批量导入性能测试

## 7. 错误处理与备份机制

### 7.1 数据库错误处理策略
```kotlin
class DatabaseErrorHandler(
    private val database: SmartDosingDatabase,
    private val context: Context
) {

    companion object {
        private const val TAG = "DatabaseErrorHandler"
    }

    /**
     * 处理数据库损坏
     */
    suspend fun handleDatabaseCorruption(): Boolean {
        return try {
            // 1. 创建备份
            val backupFile = createEmergencyBackup()

            // 2. 删除损坏的数据库
            database.close()
            val dbFile = File(context.getDatabasePath(SmartDosingDatabase.DATABASE_NAME).absolutePath)
            dbFile.delete()

            // 3. 重新创建数据库
            val newDatabase = SmartDosingDatabase.getDatabase(context)

            // 4. 尝试从备份恢复
            backupFile?.let { restoreFromBackup(it, newDatabase) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "数据库恢复失败", e)
            false
        }
    }

    /**
     * 处理约束违反异常
     */
    suspend fun handleConstraintViolation(error: SQLiteConstraintException): DatabaseError {
        return when {
            error.message?.contains("UNIQUE constraint failed: recipes.code") == true -> {
                DatabaseError.DuplicateRecipeCode(extractCodeFromError(error))
            }
            error.message?.contains("FOREIGN KEY constraint failed") == true -> {
                DatabaseError.ForeignKeyViolation("关联数据不存在")
            }
            else -> DatabaseError.UnknownConstraintError(error.message ?: "未知约束错误")
        }
    }

    /**
     * 创建数据库备份
     */
    suspend fun createBackup(): File? {
        return try {
            val backupDir = File(context.getExternalFilesDir("backups"), "database")
            backupDir.mkdirs()

            val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
            val backupFile = File(backupDir, "smartdosing_backup_$timestamp.db")

            val originalDb = context.getDatabasePath(SmartDosingDatabase.DATABASE_NAME)
            originalDb.copyTo(backupFile, overwrite = true)

            backupFile
        } catch (e: Exception) {
            Log.e(TAG, "创建备份失败", e)
            null
        }
    }

    private fun extractCodeFromError(error: SQLiteConstraintException): String {
        // 从错误消息中提取重复的配方编码
        val regex = "recipes\\.code.*?'([^']+)'".toRegex()
        return regex.find(error.message ?: "")?.groupValues?.get(1) ?: "未知"
    }
}

/**
 * 数据库错误类型
 */
sealed class DatabaseError {
    data class DuplicateRecipeCode(val code: String) : DatabaseError()
    data class ForeignKeyViolation(val message: String) : DatabaseError()
    data class UnknownConstraintError(val message: String) : DatabaseError()
}
```

### 7.2 数据备份与恢复API
```kotlin
// 在WebServerManager中添加备份相关路由
route("/api/backup") {

    // 创建备份
    post("/create") {
        try {
            val errorHandler = DatabaseErrorHandler(database, context)
            val backupFile = errorHandler.createBackup()

            if (backupFile != null) {
                call.respond(ApiResponse(
                    success = true,
                    message = "备份创建成功",
                    data = mapOf(
                        "fileName" to backupFile.name,
                        "filePath" to backupFile.absolutePath,
                        "fileSize" to backupFile.length()
                    )
                ))
            } else {
                call.respond(
                    HttpStatusCode.InternalServerError,
                    ApiResponse<Unit>(success = false, message = "备份创建失败")
                )
            }
        } catch (e: Exception) {
            call.respond(
                HttpStatusCode.InternalServerError,
                ApiResponse<Unit>(success = false, message = "备份过程出错: ${e.message}")
            )
        }
    }

    // 下载备份文件
    get("/download/{fileName}") {
        try {
            val fileName = call.parameters["fileName"] ?: return@get call.respond(
                HttpStatusCode.BadRequest,
                ApiResponse<Unit>(success = false, message = "文件名不能为空")
            )

            val backupDir = File(context.getExternalFilesDir("backups"), "database")
            val backupFile = File(backupDir, fileName)

            if (backupFile.exists() && backupFile.isFile) {
                call.response.header(
                    HttpHeaders.ContentDisposition,
                    ContentDisposition.Attachment.withParameter(ContentDisposition.Parameters.FileName, fileName).toString()
                )
                call.respondFile(backupFile)
            } else {
                call.respond(
                    HttpStatusCode.NotFound,
                    ApiResponse<Unit>(success = false, message = "备份文件不存在")
                )
            }
        } catch (e: Exception) {
            call.respond(
                HttpStatusCode.InternalServerError,
                ApiResponse<Unit>(success = false, message = "下载失败: ${e.message}")
            )
        }
    }

    // 获取备份列表
    get("/list") {
        try {
            val backupDir = File(context.getExternalFilesDir("backups"), "database")
            val backupFiles = if (backupDir.exists()) {
                backupDir.listFiles { file -> file.isFile && file.name.endsWith(".db") }
                    ?.map { file ->
                        mapOf(
                            "fileName" to file.name,
                            "fileSize" to file.length(),
                            "createTime" to SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                                .format(Date(file.lastModified()))
                        )
                    }?.sortedByDescending { it["createTime"] as String } ?: emptyList()
            } else {
                emptyList()
            }

            call.respond(ApiResponse(success = true, data = backupFiles))
        } catch (e: Exception) {
            call.respond(
                HttpStatusCode.InternalServerError,
                ApiResponse<Unit>(success = false, message = "获取备份列表失败: ${e.message}")
            )
        }
    }
}
```

## 8. 性能优化策略

### 8.1 数据库性能优化
```kotlin
// 1. 启用WAL模式提升并发性能
@Database(
    // ... 其他配置
)
abstract class SmartDosingDatabase : RoomDatabase() {

    companion object {
        fun getDatabase(context: Context): SmartDosingDatabase {
            return Room.databaseBuilder(context, SmartDosingDatabase::class.java, DATABASE_NAME)
                .setJournalMode(RoomDatabase.JournalMode.WRITE_AHEAD_LOGGING)
                .build()
        }
    }
}

// 2. 批量操作优化
@Dao
interface RecipeDao {
    @Transaction
    suspend fun insertRecipesBatch(recipesWithMaterials: List<RecipeWithMaterials>) {
        val recipes = recipesWithMaterials.map { it.recipe }
        val materials = recipesWithMaterials.flatMap { rwm ->
            rwm.materials.map { it.copy(recipeId = rwm.recipe.id) }
        }
        val tags = recipesWithMaterials.flatMap { rwm ->
            rwm.tags.map { RecipeTagEntity(rwm.recipe.id, it) }
        }

        insertRecipes(recipes)
        insertMaterials(materials)
        insertRecipeTags(tags)
    }
}
```

### 8.2 分页查询优化
```kotlin
// Repository层分页支持
class RecipeRepository(
    private val recipeDao: RecipeDao
) {

    suspend fun getRecipesPaged(
        filter: RecipeFilter,
        pageSize: Int = 20,
        pageIndex: Int = 0
    ): PagedResult<Recipe> {
        val offset = pageIndex * pageSize

        val entities = recipeDao.getRecipesPaged(
            category = filter.category.takeIf { it.isNotEmpty() },
            customer = filter.customer.takeIf { it.isNotEmpty() },
            status = filter.status?.name,
            searchText = filter.searchText.takeIf { it.isNotEmpty() },
            sortBy = filter.sortBy.name,
            sortOrder = filter.sortOrder.name,
            limit = pageSize,
            offset = offset
        )

        val totalCount = recipeDao.getRecipeCount()
        val recipes = entities.map { entity ->
            val materials = materialDao.getMaterialsByRecipeId(entity.id)
            val tags = recipeDao.getTagsByRecipeId(entity.id)
            DataMapper.toDomainModel(entity, materials, tags)
        }

        return PagedResult(
            data = recipes,
            totalCount = totalCount,
            pageSize = pageSize,
            pageIndex = pageIndex
        )
    }
}

data class PagedResult<T>(
    val data: List<T>,
    val totalCount: Int,
    val pageSize: Int,
    val pageIndex: Int
) {
    val totalPages: Int = (totalCount + pageSize - 1) / pageSize
    val hasNextPage: Boolean = pageIndex < totalPages - 1
    val hasPrevPage: Boolean = pageIndex > 0
}
```

## 9. 测试策略

### 9.1 DAO层单元测试
```kotlin
@RunWith(AndroidJUnit4::class)
class RecipeDaoTest {

    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()

    private lateinit var database: SmartDosingDatabase
    private lateinit var recipeDao: RecipeDao
    private lateinit var materialDao: MaterialDao

    @Before
    fun setupDatabase() {
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            SmartDosingDatabase::class.java
        )
        .allowMainThreadQueries()
        .build()

        recipeDao = database.recipeDao()
        materialDao = database.materialDao()
    }

    @After
    fun closeDatabase() {
        database.close()
    }

    @Test
    fun insertRecipe_retrievesRecipe() = runTest {
        // Given
        val recipe = RecipeEntity(
            id = "test-1",
            code = "TEST001",
            name = "测试配方",
            category = "测试",
            totalWeight = 100.0,
            createTime = "2024-01-01 10:00:00",
            updateTime = "2024-01-01 10:00:00"
        )

        // When
        recipeDao.insertRecipe(recipe)
        val retrieved = recipeDao.getRecipeById("test-1")

        // Then
        assertThat(retrieved).isNotNull()
        assertThat(retrieved?.code).isEqualTo("TEST001")
        assertThat(retrieved?.name).isEqualTo("测试配方")
    }

    @Test
    fun insertDuplicateCode_throwsException() = runTest {
        // Given
        val recipe1 = RecipeEntity(
            id = "test-1", code = "TEST001", name = "配方1",
            category = "测试", totalWeight = 100.0,
            createTime = "2024-01-01 10:00:00", updateTime = "2024-01-01 10:00:00"
        )
        val recipe2 = recipe1.copy(id = "test-2", name = "配方2")

        // When & Then
        recipeDao.insertRecipe(recipe1)
        assertThrows<SQLiteConstraintException> {
            runBlocking { recipeDao.insertRecipe(recipe2) }
        }
    }

    @Test
    fun searchRecipes_returnsFilteredResults() = runTest {
        // Given - 插入多个测试配方
        val recipes = listOf(
            RecipeEntity("1", "CODE001", "苹果香精", "香精", totalWeight = 100.0, createTime = "2024-01-01 10:00:00", updateTime = "2024-01-01 10:00:00"),
            RecipeEntity("2", "CODE002", "柠檬酸", "酸类", totalWeight = 200.0, createTime = "2024-01-02 10:00:00", updateTime = "2024-01-02 10:00:00"),
            RecipeEntity("3", "CODE003", "苹果酸", "酸类", totalWeight = 150.0, createTime = "2024-01-03 10:00:00", updateTime = "2024-01-03 10:00:00")
        )
        recipes.forEach { recipeDao.insertRecipe(it) }

        // When - 搜索包含"苹果"的配方
        val results = recipeDao.getRecipesPaged(
            category = null, customer = null, status = null,
            searchText = "苹果", sortBy = "NAME", sortOrder = "ASC",
            limit = 10, offset = 0
        )

        // Then
        assertThat(results).hasSize(2)
        assertThat(results[0].name).isEqualTo("苹果酸")
        assertThat(results[1].name).isEqualTo("苹果香精")
    }
}
```

## 10. 更新后的时间估算与里程碑

### 10.1 详细时间规划

| 阶段 | 任务内容 | 预估时间 | 关键输出物 | 验收标准 |
|------|---------|---------|-----------|---------|
| **阶段0** | 基础准备 | **1天** | 项目配置、依赖管理 | ✅ Room依赖配置完成<br>✅ 数据库包结构创建 |
| **阶段1** | 数据访问层 | **2-3天** | Entity、DAO、Database主类 | ✅ 所有实体类编译通过<br>✅ DAO单元测试通过<br>✅ 数据库初始化成功 |
| **阶段2** | Repository改造 | **2天** | 新Repository实现 | ✅ 原有接口保持兼容<br>✅ 数据正确持久化<br>✅ Flow响应式更新正常 |
| **阶段3** | 导入模块改造 | **1天** | 新ImportManager | ✅ CSV/Excel导入正常<br>✅ 批量操作事务完整<br>✅ 导入日志记录准确 |
| **阶段4** | Web服务集成 | **1天** | 更新后的API | ✅ 所有现有API正常工作<br>✅ 新增备份API可用<br>✅ 分页查询性能良好 |
| **阶段5** | 测试与验证 | **2天** | 测试套件 | ✅ 单元测试覆盖率>80%<br>✅ 集成测试通过<br>✅ 性能基准达标 |
| **总计** | **全部阶段** | **🎯 9-10天** | 完整SQLite集成 | ✅ 数据持久化可靠<br>✅ 性能满足需求<br>✅ 错误处理完善 |

### 10.2 里程碑检查点

#### **里程碑 A：数据库基础就绪 (第3天结束)**
**验收条件**：
- ✅ SmartDosingDatabase可正常创建和连接
- ✅ 所有Entity和DAO编译无错误
- ✅ 基础CRUD操作单元测试通过
- ✅ 数据库初始化和示例数据插入成功

**关键代码验证**：
```kotlin
// 验证数据库连接
val database = SmartDosingDatabase.getDatabase(context)
val recipeCount = database.recipeDao().getRecipeCount()
assert(recipeCount > 0) // 确保示例数据已插入
```

#### **里程碑 B：Repository层迁移完成 (第5天结束)**
**验收条件**：
- ✅ RecipeRepository完全切换到数据库存储
- ✅ 现有UI界面数据显示正常（无回归问题）
- ✅ StateFlow/Flow数据流响应正常
- ✅ 复杂查询和筛选功能正确工作

**关键功能验证**：
```kotlin
// 验证Repository数据持久化
val repository = RecipeRepository(database.recipeDao())
val initialCount = repository.getAllRecipes().size

// 重启应用模拟
database.close()
val newDatabase = SmartDosingDatabase.getDatabase(context)
val newRepository = RecipeRepository(newDatabase.recipeDao())
val afterRestartCount = newRepository.getAllRecipes().size

assert(initialCount == afterRestartCount) // 数据持久化验证
```

#### **里程碑 C：Web服务完整集成 (第7天结束)**
**验收条件**：
- ✅ Web API所有现有接口正常工作
- ✅ CSV/Excel导入功能数据持久化
- ✅ 新增备份和恢复功能可用
- ✅ 分页查询性能满足要求(查询响应<100ms)

**API测试验证**：
```bash
# 验证配方查询API
curl "http://localhost:8080/api/recipes?page=0&size=10"

# 验证导入功能
curl -X POST -F "file=@test_recipes.csv" "http://localhost:8080/api/import/recipes"

# 验证备份功能
curl -X POST "http://localhost:8080/api/backup/create"
```

#### **里程碑 D：生产就绪 (第10天结束)**
**验收条件**：
- ✅ 完整测试套件通过（单元测试+集成测试）
- ✅ 性能基准测试达标
- ✅ 错误处理和恢复机制验证完成
- ✅ 文档和使用指南完善

### 10.3 风险控制点

#### **高风险点控制**
| 风险项 | 风险级别 | 控制措施 | 应急预案 |
|-------|---------|---------|---------|
| 数据迁移失败 | 🔴 **高** | • 充分的单元测试<br>• 分阶段迁移<br>• 数据映射验证 | • 回滚到内存存储<br>• 数据重新导入 |
| 性能不达预期 | 🟡 **中** | • 分页查询设计<br>• 索引优化<br>• 批量操作事务 | • 调整查询策略<br>• 优化数据库结构 |
| API兼容性问题 | 🟡 **中** | • 保持接口不变<br>• 渐进式重构<br>• API测试覆盖 | • 快速修复<br>• 接口版本控制 |
| 并发访问冲突 | 🟢 **低** | • WAL模式启用<br>• 事务隔离<br>• 错误处理 | • 重试机制<br>• 锁超时处理 |

#### **每日检查清单**
- [ ] **Day 1-3**: Entity和DAO是否编译通过？单元测试是否全部绿色？
- [ ] **Day 4-5**: Repository接口是否保持兼容？现有UI是否正常？
- [ ] **Day 6-7**: Web API是否正常响应？导入功能是否正确持久化？
- [ ] **Day 8-10**: 完整流程是否端到端验证？性能是否达标？

### 10.4 成功标准定义

#### **功能完整性标准**
- ✅ **数据持久化**：应用重启后所有数据完整保存
- ✅ **功能保持**：现有所有功能正常工作，无功能回归
- ✅ **性能达标**：配方查询<100ms，导入1000条记录<10s
- ✅ **稳定性**：连续运行24小时无异常，错误恢复机制有效

#### **技术质量标准**
- ✅ **代码质量**：新增代码遵循项目规范，注释完整
- ✅ **测试覆盖**：单元测试覆盖率>80%，关键路径100%覆盖
- ✅ **文档完善**：API文档、数据库设计文档、部署指南齐全
- ✅ **可维护性**：模块解耦清晰，易于后续功能扩展

---

## 📋 项目交付清单

### 核心交付物
- [ ] **完整的SQLite数据库集成**（Entity + DAO + Database）
- [ ] **重构后的Repository层**（保持接口兼容，内部数据库驱动）
- [ ] **优化的Web API服务**（新增备份、分页、错误处理）
- [ ] **完善的测试套件**（单元测试 + 集成测试 + 性能测试）
- [ ] **技术文档集合**（数据库设计、API文档、部署指南）

### 扩展特性
- [ ] **数据备份与恢复系统**
- [ ] **导入日志和审计功能**
- [ ] **分页查询和性能优化**
- [ ] **错误处理和异常恢复机制**

通过这个更新后的计划，SmartDosing项目将获得稳健的数据持久化能力，为后续的功能扩展（如多端同步、用户权限、高级统计等）奠定坚实基础！

## 附录

### A. 依赖版本信息
```kotlin
// app/build.gradle.kts 添加以下依赖
dependencies {
    // Room components
    implementation "androidx.room:room-runtime:2.6.1"
    implementation "androidx.room:room-ktx:2.6.1"
    kapt "androidx.room:room-compiler:2.6.1"

    // Testing
    testImplementation "androidx.room:room-testing:2.6.1"
    testImplementation "androidx.arch.core:core-testing:2.2.0"
    androidTestImplementation "androidx.test.ext:junit:1.1.5"
    androidTestImplementation "androidx.test.espresso:espresso-core:3.5.1"
}
```

### B. 数据库文件位置
```
Android设备: /data/data/com.example.smartdosing/databases/smartdosing.db
备份位置: /sdcard/Android/data/com.example.smartdosing/files/backups/database/
```

### C. 关键性能指标
- **配方查询**: < 100ms（1000条数据）
- **批量导入**: < 10s（1000条配方）
- **数据库大小**: < 50MB（10000条配方）
- **备份时间**: < 5s（完整数据库）
